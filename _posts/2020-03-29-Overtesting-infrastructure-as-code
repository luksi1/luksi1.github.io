# Applying SOLID principles to Infrastructure-as-Code

SOLID principles are the cornerstone of object-oriented programming and for good reason. These principles allow us to produce flexible, testable, and clearly defined digital nuggets that can continuously provide customer value throughout their lifetime.

In the following sections, I'll take a look at how to apply SOLID concepts to IaC, the natural evolution of an IaC monolith, the pitfalls of that evolution, and some ways to address those pitfalls.

## SOLID

SOLID is an mneumonic acronym for:

- Single-responsibility principle
- Open-closed principle
- Liskov substituion principle
- Interface segmentation principle
- Dependency inversion principle

### Single-responsibility principle

A class should do one thing and only one thing.

### Open-closed principle

A class should be open for extension, but closed for modification.

### Liskov substitution principle

An object should be able to be replaced by any of its subtypes, without altering the subtypes behavior. We'll focus mostly on design by contract, which is the basis for this principle.

### Interface segmentation principle

Client specific interfaces are better than broad catch-all interfaces.

### Dependency inversion principle

Modules should depend on abstractions. Programs should not be built like pyramids, but rather each building block should have a clear abstraction layer.

## Infrastructure as Code

SOLID principles are used as the basis for virtually all, if not all, object oriented software. These principles exist so that software can be more flexible, maintainable, and usable. This guide will attempt to apply these same methods to Infrastructure as Code.

### Problems

What do you do when you need to modify your PowerShell script that it is well over 2 000 lines of code? What do you do when you realize that thing you're automatically can't be tested? And that thing has now become VERY important for the life of the enterprise? What do you do when you realize that only you can use your code? These are not problems I've heard on the streets. These are problems I've experienced first hand. I've also come to understand that these problems are not unique to IaC. In fact, SOLID principles were designed 30 years ago to tackle these specific software design problems. Here, we're going to use these principles to tack IaC design problems.

### IaC design

You should be using some way to abstract your IaC modules. You should never be building code to get the status of a service or install a package. These code nuggets should be abstracted, tested, and have a clear interface and then, and only then, can these nuggets be used to build something greater. 

In Puppet this is applied with "roles and profiles". In Ansibile, it's applied with "roles". Although I don't know every IaC tool out there, I would argue that if you do not have the ability to create a tower will Legos, but are rather forced to mold your own tower, you would probably be best served looking elsewhere.

"Role and profiles" in Puppet and "roles" in Ansible allow you to build modules with clearly defined interfaces. For example, you can create a MySQL module. You can create an Oracle module. You can create an IIS module. You can then tie these modules together to produce some sort of business value.

This type of design attempts to fullfil these principles. Each module has a single responsibility. Each module is open for extension (we can for example add a provider to for Gentoo or FreeBSD), but it's closed for modification. Each module has a specific contract and a specific client interface. Finally, are dependency is only on the interface of these modules, not on their concretions.

### IaC design gone to shit

We can use SOLID design principles to create well-defined, manageable modules, but what happens when your monolith get unruly? A few applications become a hundred. Even a few people merging to the same repsoitory can quickly escalate into merge hell.

#### Release your infrastructure

Your "roles" module or your "profiles" module needs to be released like regular code. Tag it. Create a CHANGELOG. Create a release candidate and promote it eventually to production.

#### Choose a branching strategy

Choose GitFlow, GitHubFlow, GitLabFlow... whatever. Choose a flow and stick with it. All of these strategies requires branching. Branch your feature and submit merge requests. Your team will be happy and those pitfalls should start to magically disappear.

#### Unit test your modules

If you are going to have a well-defined contract that is going to do one specific thing, it's import to test the various ways someone might be able to call that interface, so that you can be assured that your module delivers what it says it will deliver. What happens if you try to install a package on Gentoo, SUSE, RedHat, Ubuntu... What happens if I try to install an ssh key on Windows? A module should be able to handle these use cases (or not handle them, but then they should exit gracefully).

#### Don't unit test your "roles" or "profiles"

This sounds counterintuitive, but you would never unit test a "main" function in a software program. That's absurd. Your "roles" or "profile" is a "main" class or an entrypoint to your infrastructure. This should not be unit tested (and if so, only so that it compiles). It should though have integration tests, system tests and the works. It's easy to get bogged down in unit testing here, but don't. It provides no value and that logic should have been already tested in your module.
